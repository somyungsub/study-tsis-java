======================================================
3.4 컨텍스트와 DI
======================================================

- 3.4.1 JdbcContext의 분리
-- jdbcContext는 변경 가능성이 없을꺼 같아 특별히 인터페이스를 사이에 두지 않고 구현하고 DI함
- 3.4.2 JdbcContext으 특별한 DI
-- 런터임시 결정되는 DI 형식은 아니지만, 스프링DI로 보자면 객체의 생성과 관계설정에 대한 제어권을
오브젝트에서 제거하고 외부로 위임했다는  IOC라는 개념을 포괄한다. 그러므로 DI의 기본을 따르고 있다.
--JdbcContext를 UserDao와 DI로 구분짓는 이유.
1. 상태값을 갖고있지 않으므로 빈으로 등록되어 싱글턴 형식으로 사용되는게 유용하다.
2. datasource를 di받으므로 jdbcContext또한 빈으로 등록 되어야한다.
* 이 둘은 강한결합을 나타낸다 만약 jdbc에서 하이버네이트나 jpa로 바꾸면 이걸 통째로 바꿔야한다.!
--직접 주입하는 방법으로  dataSourece를 주입받고 dataSource Setter에 jdbcContext 주입하는 로직을 넣는다.(이러면 싱글톤으로 관리 되지 않게 됨)

-- 요약 
여러 메소드에서 쓰는 jdbcContext를 UserDao에서 분리한다. 하지만 인터페이스를 구현하지 않는 특별한 방법으로 구현 한다.
이방법은 강한결합을 나타내는 결합인데... 자주 사용 되는 방식은 아니다.
이렇게 구현된 jdbcContext는 빈으로 등록하여 사용하는 방법과 dataSource의 setter에서 생성해서 사용하는 두가지 방법이 있다. 
정답은 없다. 각자의 방법에 맞게 사용 하면 된다. 

3.5 템플릿과 콜백
-- 전략패턴의 기본 구조에 익명 내부 클래스를 활용한 방식을 스프링에서는 템플릿/콜백 패이라 부른다.

3.5.1. 템플릿/콜백의 동작원리
--Client 가 template에게 callback을 던져주면 template는 callback을 실행 callback은 client의 final 변수를 참조하고 실행됨 
다시  template에게 실행 권한이 넘어가고 종료
3.5.2 편리한 콜백의 재활용
--userDao에서 매번생성하던 익명클래스를 재활용 가능한 부분을 찾아 리팩토링. 여기서는 쿼리문을 제외한 부분이
계속해서 사용되므로 쿼리만받고 나머지를 excuteSql메소드로 빼준다. 하지만 이것을 여기서만 쓰기 아까우니
jdbcContext에 넣어서 다 사용하게 해준다.
--?? 파라미터를  final로 선언하는 이유???? 

3.5.3 템플릿/콜백의 응용
--  제네릭을 활용하면 다양한 타입을 받을 수 잇어용~
* 고정된 작업 흐름을 갖고 있으면서 여기저기서 자주 반복되는 코드가 있다면, 중복되는 코드를 분리할 방법을 생각해보는 습관을 기르자.

3.6 스프링의 JdbcTemplate
-- 템플릿 콜백 기본동작 원리를 알았으니 이번에는 스프링에서 제공해주는 방법을 알아보자.
-- JdbcContext를 버리고 스프링에서 제공해주는 JdbcTemplate를 사용하자.
======================================================
 단어
======================================================



