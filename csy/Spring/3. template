

3 템플릿


3.1 다시보는 초난감 DAO
- 예외처리 try/catch/finally
- 리소스 반환의 중요성 

3.2 변하는 것과 변하지 않는 것
- 분리와 재사용을 위한 디자인 패턴(템플릿 메소드 패턴)
- 템플릿 메소드 : 상속을 통해 기능을 확장해서 사용. 변하지 않는 부분은 부모클래스에 변하는 부분은 추상클래스에 정의하여 서브클래스에서 오버라이드함
- 장점 : OCP(개방폐쇄원칙) 지킴
- 단점 : DAO로직마자 새로운 상속을 해야하고 / 확장구조가 클래스 설계 시점에서 고정(런타임시 의존성주입 안 됨?)
- 대체 : 전략패턴 : 오브젝트를 분리하고 클래스 레벨에서는 인터페이스를 통해서만 의존하도록 만듬
- CONTEXT : 바뀌지 않는 부분, STRATEGY: 바뀌는 부분 인터페이스를 통해 유연하게 확장

3.3 JDBC 전략 패턴의 최적화
- UserDao의 메소드 : 클라이언트 / 익명내부클래스 : 전략 / jdbcContextWithStatementStrategy() 메소드 : 컨텍스트

3.4 컨텍스트와 DI
- 목표 : 클라이언트 내의 메소스 레벨의 컨텍스트를 분리시켜 공유 
- UserDao <-> jdbcContext : 의존관계 : jdbcContext를 setjdbcContext()를 통해 런타임시 DI 받음
- jdbcContext  <-> DataSource : 의존관계  jdbcContext에서 DataSource를 DI 받도록 함 -> workWithStatementStrategy()를 통해 
- DataSource :인터페이스
--------------------------
- 인터페이스가 없이 클래스를 직접 의존하는 DI : 두 오브젝트가 매우 긴밀한 관계를 가지고 강하게 결합됨 : 강한 응집도 ==> 특정기능에 사용가능
- 방법1. 스프링 빈 DI : 인터페이스를 사이에 둬서 클래스 레벨에서는 의존관계가 고정되지 않아야하고
                       런타임시에 의존할 오브젝트와의 관계를 다이내믹하게 주입
- 넓게보면 생성과관계설정에 대한 제어권한을 오브젝트->외부로 위임 : IoC 개념을 포괄
- 방법2. 클라이언트에서 직접 코드로 수동으로 DI 받는 방법  

3.5 템플릿과 콜백
- 전략패턴의 기본구조에 익명 내부 클래스를 활용한 방식
- 일정한 패턴을 갖는 작업 흐름이 있고 그 중 일부분만 자주 바꿔서 사용해야하는 경우
- 전략패턴 컨텍스트 : 템플릿 / 익명내부클래스로 만들어지는 오브젝트 : 콜백 
- 템플릿 : 일정한 패턴을 갖고 변하지 않는 작업을 하는 역할
- 콜백 : 실행되는 것을 목적으로 다른 오브젝트의 메소드에 전달되는 오브젝트
-     전략패턴의 전략      |     템플릿/콜백의 콜백
  -여러 메소드 인터페이스       - 단일메소드 인터페이스(특정기능 보통 1번 호출)
- DI 방식의 전략 패턴 구조 
- 특징1. 매번 메소드 단위로 사용할 오브젝트를 새로 전달받음
- 특징2. 콜백 오브젝트가 내부클래스로서 자신을 생성한 클라이언트 메소드 내의 정보를 직접 참조
- 콜백 리팩토링

 템플릿/ 콜백 패턴 적용
 *  1. 템플릿에 담을 반복되는 작업 흐름 ?
 *   --> 템플릿이 BufferedReader를 만들어서 콜백에게 전달 -> 콜백이 각 라인을 읽어서 처리 후 최종결과를 템플릿에게 돌려줌
 *    (br:파일을 열어서 각 라인을 읽어올 수 있는 )
 *    
 *   
 *  2. 템플릿이 콜백에게 전달해줄 내부의 정보?
 *   ->콜백 오브젝트를 호출하여 템플릿에서 만든 bufferedReader(context)를 전달
 *  
 
 *  3. 콜백이 템플릿에게 돌려줄 내용?
 *  
 *  
 *  4. 템플릿이 작업을 마친 뒤 클라이언트에게 전달해줘야 하는것?
 *  
 *  
 *  5. 템플릿과 콜백의 경계

3.6 스프링의 JDBCTEMPLATE


