# AOP
**AOP는 IoC/DI, 서비스 추상화와 함께 Spring 3대 기반 기술이다**  
관점 지향 프로그래밍... 트랜잭션에서 시작  
트랜잭션 코드와 비즈니스 코드의 분리 -> 여기에서 트랜잭션 코드 같은 경우는 동일하게 사용될 수 있다.  분리를 하여 따로 작성하면서 적절히 트랜잭션에 대한 처리!  

여기에서 등장하는 개념이 AOP  


### @Autowired의 문제점 
- `type 기반으로 빈을 찾음` -> 상위타입 Autowired일 경우 하위타입이 2개이상이면 에러 발생.. (애매하다고 알려줌)

## 고립된 단위 테스트 
테스트의 가장 좋은 단위는 `가능한 가장 작게 쪼개서 테스트`  
- 테스트 실패시 원인 분석이 빠름 


### 테스트 대상의 의존대상 
A를 테스트하고 싶은데 A와 관계를 갖는 B,C,D 클래스가 존재하는 경우  
그리고 B,C,D는 또 각각 의존관계를 갖는 다른 클래스도 존재 할 것이다. 즉 여러곳에 영향을 받거나 미치고 있는셈..
이럴 경우 테스트는 A를 하고싶었는데.. 다른게 더 신경쓰이게 되버리는 현상이 나오는 것이다.  

### 테스트 대상 오브젝트 고립
그래서 테스트의 대상이 환경, 외부서버, 다른클래스의 코드에 종속되고 `영향을 받지 않도록 고립시켜야한다.`  
-> 목오브젝트 작성을 하여 적절히 구현
-> 구현시 사용안하는 메서드는  
   ```java
   // 사용안하는 메서드 :  예외 처리 -> 사용안하는 거라고 명시
   public void add(){
     throw new UnsupportedOperationException() 
   }
   ```

### 단테, 통테
단테의 경우를 항상 먼저 생각, 외부 리소스를 사용해야하는 경우 통테, 단테의 어려움 (ex DAO)도 존재.  
`스프링 테스트 컨텍스트 프레임워크` -> `통합테스트`  

### Mockito 프레임워크
목의 기반이 되는 개념이 `프록시의 스텁` 같은 느낌  
`목오브젝트`를 일일이 작성하는 것을 대신해주는 프레임워크, 즉 기존처럼 작성할 필요가 없음!! 개신박함!!!  

- Java 클래스 임포트
```java
// mock 메서드 사용을 위한 클래스 임포트
import static org.mockito.Mockito.*;
```
- 라이브러리 maven 추가
```xml
  <dependency>
    <groupId>org.mockito</groupId>
    <artifactId>mockito-all</artifactId>
    <version>1.10.19</version>
    <scope>test</scope>
  </dependency>
```

## 다이내믹 프록시와 팩토리빈
- 기본 사용법
  mock, when, thenReturn, verify, times, any 메서드
  ```java
  @Test
  public void mockitoTest() {

    // mock 생성
    UserDao mockUserDao = mock(UserDao.class);

    // 스텁기능 추가 : getAll 메서드가 호출됐을때, users 리스트를 리턴해주세요 라는 의미
    when(mockUserDao.getAll()).thenReturn(this.users);

    // 해당메서드(update)의 실행여부 검증 : update 메서드가 2번 실행됐는지 확인(verify)하라
    verify(mockUserDao, times(2)).update(any(User.class));
  }
  ```

- 데코레이터
데코레이터 패턴.. 디패에서 배웠던 내용 요약.. 동적으로 기능을 추가할 수 있게 구현된 패턴 

- 프록시
프록시, 대리인 역활, 접근제어, 스텁과 목의 기반이되는 개념  
RMI 등 원격 프록시  
타겟 인터페이스에 위임, 실제 필요한 경우 실제 object를 호출

- 리플렉션
클래스에 대한 정보를 얻거나, 인스턴스 생성 등 동적으로 구현할 수 있음  
`X.class 나 x.getClass()` 를 활용하여 `Class 클래스`를 통해 정보를 얻을 수 있음  
```java
  @Test
  public void reflectStringTest() throws NoSuchMethodException, InvocationTargetException, IllegalAccessException {
    String name = "Spring";

    // length
    assertThat(name.length(), CoreMatchers.is(6));
    Method method = String.class.getMethod("length");
    assertThat(method.invoke(name), CoreMatchers.is(6));

    // charAt
    assertThat(name.charAt(0), CoreMatchers.is('S'));
    Method method2 = String.class.getMethod("charAt", int.class);
    assertThat(method2.invoke(name, 0), CoreMatchers.is('S'));
  }
```

- 다이나믹 proxy 클래스
```java

// Hello 인터페이스 
public interface Hello {
  String sayHello(String name);

  String sayHi(String name);

  String sayThankYou(String name);
}

// 타겟 오브젝트
public class HelloTarget implements Hello {
  @Override
  public String sayHello(String name) {
    return "Hello " + name;
  }

  @Override
  public String sayHi(String name) {
    return "Hi " + name;
  }

  @Override
  public String sayThankYou(String name) {
    return "Thank You " + name;
  }
}


// 다이나믹 Proxy에서 사용할 부가기능 : InvocationHandler를 꼭 구현해야함
public class UppercaseHandler implements InvocationHandler {
  Hello target; // 타겟 인터페이스

  public UppercaseHandler(Hello target) {
    this.target = target;
  }

  @Override
  public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
    String ret = (String) method.invoke(target, args);
    return ret.toUpperCase();
  }
}
```

### `장점`  
HelloUppercase 같은경우 메서드가 3개에 불과하지만 이것이 30개라고 한다면...? 확장에 대한 유연성이 정적클래스로 만든것과 다이나믹 Proxy를 활용하여 만든것은 엄청난 차이가 난다.. 

현재 상태에서 `Hello 인터페이스`의 메서드를 30개로 늘린다 치면,  
1. Hello 인터페이스 30개 추가
2. Hello 인터페이스를 구현하는 구현체(ex HelloUppsercase)도 인터페이스에 맞게 30개 구현 -> **여기가 문제점**
3. 구현체가 2개,3개 ... 많으면 많을수록 수정사항이 많이 발생

**`다이나믹 Proxy를 이용한다면..`**  
1. Hello 인터페이스 30개 추가 끝

### 빈생성 방법
디폴트 생성자 외 `팩토리빈`으로 빈을 생성.  

**`팩토리빈`**이란 스프링을 대신해서 오브젝트 생성 로직을 담당하도록 만들어진 특별한 빈.  

- FactoryBean 인터페이스 구현


`private 생성자` -> 객체 생성은 static 메서드로 구현, 스프링 빈으로 등록하지 말것, 리플렉션을 이용해서 생성은가능하다  
getBean("&이름") -> factoryBean을 들고옴

- 트랜잭션 프록시 팩토리빈 -> 유연하게 트랙잰션 기능을 제공할 수 있도록해줌
  `Class<?>의 serviceInterface`가 타입으로 설정 됨  
  Obejct의 target은 그 타겟이 되는 대상이 무궁무진  
```java
public class TxProxyFactoryBean implements FactoryBean {
  Object target;
  PlatformTransactionManager transactionManager;
  String pattern;
  Class<?> serviceInterface;

  public void setTarget(Object target) {
    this.target = target;
  }

  public void setTransactionManager(PlatformTransactionManager transactionManager) {
    this.transactionManager = transactionManager;
  }

  public void setPattern(String pattern) {
    this.pattern = pattern;
  }

  public void setServiceInterface(Class<?> serviceInterface) {
    this.serviceInterface = serviceInterface;
  }

  @Override
  public Object getObject() throws Exception {
    TransactionHandler handler = new TransactionHandler();
    handler.setTarget(target);
    handler.setTransactionManager(transactionManager);
    handler.setPattern(pattern);

    return Proxy.newProxyInstance(
        getClass().getClassLoader(),
        new Class[]{serviceInterface},
        handler
    );
  }

  @Override
  public Class<?> getObjectType() {
    return serviceInterface;
  }

  @Override
  public boolean isSingleton() {
    return false;
  }
}
```

다이나믹 Proxy의 단점은... 타깃 오브젝트가 늘어나면 그만큼 Proxy를 만들어줘야하는... 상황이 발생...  
-> 그렇게되다보면 설정 부분도 중복...
-> 해결책은 ? 팩토리빈
-> 팩토리빈 -> 스프링팩토리빈

## 스프링의 프록시 팩토리 빈
`프록시 오브젝트를 생성해주는 기술`을 추상화한 팩토리 빈  

### ProxyFactoryBean  
- 순수하게 Proxy 생성만 담당. 기존에 트랜잭션 부가기능이 들어간 만든 TxProxyFactoryBean하고는 기능만 다름
- 즉 순순 Proxy 생성만 담당 / 부가기능은 따로 정의하여 사용
- `기능과 역활의 분리.... 미친듯한 설계.. 감탄`

### org.aopalliance.intercept.MethodInterceptor extends Advice
- 부가기능은 `MethodInterceptor 인터페이스 구현`을 통해 만듬
- **InvocationHandler 인터페이스와 다르다** -> 이녀석의 invoke 메서드에서는 타깃오브젝트의 정보를 제공하지 않음
- MethodInterceptor의 invoke 메서드 -> ProxyFactoryBean으로 부터 타깃오브젝트를 제공 받음. 따라서 타깃오브젝트에 구애 받지 않고 독릭접으로 구현 가능
- 그래서 여러 프록시에 함께 사용, 싱글톤 빈 등록 가능
- invoke 메서드의 경우 -> `methodInvocation.proceed()`는 Method와 달리 `타깃 정보를 함꼐 전달한다`
- `Advice 인터페이스를 상속`하는 인터페이스 


### 어드바이스 ! (타깃오브젝트가 필요없는 `순수한 부가기능`)
- MethodInvocation 같은 경우 타깃오브젝트와 함께 전달하여 실행하게 되며, 부가기능 구현에만 집중할 수 있도록 함
기 구현했던 InvocationHandler와의 차이점이다.  

- MethodInvocation은 일종의 콜백 오브젝트, procced 메서드 -> `타깃오브젝트의 메서드를 내부적으로 실행`
- ProxyFactoryBean.addAdvice() -> 여러 개의 MethodInvocation을 추가할 수 있다는 장점  
-> 즉, ProxyFactoryBran에 여러 가지 부가기능을 넣을 수 있음을 의미
- 타깃에 부가기능을 적용하는 것을 `스프링에서는 어드바이스`라고 한다
- 순수한 기능을 담은 오브젝트라 할 수 있음


### 포인트 컷  ! 부가기능 적용대상의 메소드 선정
메소드 선정 알고리즘  
**ProxyFactoryBean -> Advice(부가기능) + PointCut(대상메서드) 관리 및 적용**
- NameMatchMethodPointcut (스프링 제공)

### 어드바이저 = advice + pointcut
DefaultPointcutAdvisor (스프링 제공)

- 어드바이스 따로, 포인트컷 따로 등록을 안하는 이유는 어떤 어드바이스에 어떤 포인트컷이 적용될지 애매해지기 때문이다.  
  따라서 어드바이저로 등록을 해야한다.

### xml 설정
```xml
    <!-- Advice 설정 -->
    <bean id="transactionAdvice" class="chap06_AOP.TransactionAdvice">
        <property name="transactionManager" ref="transactionManger"/>
    </bean>

    <!-- PointCut 설정 -->
    <bean id="transactionPointcut" class="org.springframework.aop.support.NameMatchMethodPointcut">
        <property name="mappedName" value="upgrade*"/>
    </bean>

    <!-- Advisor 설정-->
    <bean id="transactionAdvisor" class="org.springframework.aop.support.DefaultPointcutAdvisor">
        <property name="advice" ref="transactionAdvice"/>
        <property name="pointcut" ref="transactionPointcut"/>
    </bean>

    <!-- ProxyFactoryBean 설정 -->
    <bean id="userServiceProxy" class="org.springframework.aop.framework.ProxyFactoryBean">
        <property name="target" ref="userServiceImpl"/>
        <property name="interceptorNames">
            <list>
                <value>transactionAdvisor</value>
            </list>
        </property>
    </bean>
```
**interceptorNames** 속성 -> `어드바이스와 어드바이저를 혼합`해서 설정 가능하다  

## 스프링 AOP




